/*
 * Copyright (c) 2022, NVIDIA CORPORATION.  All rights reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package main

import (
	"context"
	"encoding/json"
	"io/ioutil"
	"os"
	"path/filepath"

	"k8s.io/klog/v2"
	drapbv1 "k8s.io/kubernetes/pkg/kubelet/apis/dra/v1alpha1"

	cdiapi "github.com/container-orchestrated-devices/container-device-interface/pkg/cdi"
	"github.com/container-orchestrated-devices/container-device-interface/specs-go"

	clientset "github.com/NVIDIA/k8s-dra-driver/pkg/crd/nvidia/clientset/versioned"
	nvcrd "github.com/NVIDIA/k8s-dra-driver/pkg/crd/nvidia/v1"
	"github.com/NVIDIA/k8s-dra-driver/pkg/plugin"
)

const (
	cdiVersion = "0.4.0"
	cdiRoot    = "/etc/cdi"
	cdiVendor  = "nvidia.com"
	cdiKind    = cdiVendor + "/gpu"
)

type driver struct {
	config *Config
	gpucrd *GpuCRD
}

func startPlugin(config *Config, clientset *clientset.Clientset) error {
	gpucrd, err := NewGpuCRD(config, clientset)
	if err != nil {
		return err
	}

	err = os.MkdirAll(DriverPluginPath, 0750)
	if err != nil {
		return err
	}

	err = os.MkdirAll(cdiRoot, 0750)
	if err != nil {
		return err
	}

	err = plugin.StartRegistrationServer(DriverName, DriverPluginSocket, PluginRegistrationPath)
	if err != nil {
		return err
	}

	d := &driver{
		config: config,
		gpucrd: gpucrd,
	}

	s := plugin.NewNonBlockingGRPCServer()
	s.Start(DriverPluginSocket, d)
	s.Wait()

	return nil
}

func (d *driver) NodePrepareResource(ctx context.Context, req *drapbv1.NodePrepareResourceRequest) (*drapbv1.NodePrepareResourceResponse, error) {
	klog.Infof("NodePrepareResource is called: request: %+v", req)

	var parameters nvcrd.GpuParameterSet
	err := json.Unmarshal([]byte(req.ResourceHandle), &parameters)
	if err != nil {
		return &drapbv1.NodePrepareResourceResponse{}, err
	}

	klog.Infof("Creating CDI File")
	klog.Infof("parameters: %v", parameters)

	cdiDeviceName := "device-" + string(req.ClaimUid)[0:8]
	cdiFilePath := filepath.Join(cdiRoot, cdiDeviceName+".json")

	containerEdits := &cdiapi.ContainerEdits{}
	containerEdits.Append(&cdiapi.ContainerEdits{ContainerEdits: &specs.ContainerEdits{
		Env: []string{"NVIDIA_VISIBLE_DEVICES=0,1"},
	}})

	contents := &specs.Spec{
		Version: cdiVersion,
		Kind:    cdiKind,
		Devices: []specs.Device{{
			Name:           cdiDeviceName,
			ContainerEdits: *containerEdits.ContainerEdits,
		}},
	}

	spec, err := cdiapi.NewSpec(contents, cdiFilePath, 0)
	if err != nil {
		klog.Infof("CDI spec is not validated: %v", err)
		return nil, err
	}

	klog.Infof("CDI spec is validated")

	// create json file from spec
	doc, err := json.Marshal(*spec)
	if err != nil {
		klog.Infof("json marshal error: %v", err)
		return nil, err
	}

	if err := ioutil.WriteFile(cdiFilePath, doc, os.FileMode(0644)); err != nil {
		klog.Infof("error writing file: %v", err)
		return nil, err
	}

	klog.Infof("Json file is created at " + cdiFilePath)

	//return qualified name of the cdi device
	dev := spec.GetDevice(cdiDeviceName).GetQualifiedName()
	klog.Infof("Return: " + dev)
	return &drapbv1.NodePrepareResourceResponse{CdiDevice: []string{dev}}, nil
}

func (d *driver) NodeUnprepareResource(ctx context.Context, req *drapbv1.NodeUnprepareResourceRequest) (*drapbv1.NodeUnprepareResourceResponse, error) {
	klog.Infof("NodeUnprepareResource is called: request: %+v", req)
	cdiDeviceName := "device-" + string(req.ClaimUid)[0:8]
	cdiFilePath := filepath.Join(cdiRoot, cdiDeviceName+".json")
	os.Remove(cdiFilePath)
	return &drapbv1.NodeUnprepareResourceResponse{}, nil
}
